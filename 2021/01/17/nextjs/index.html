<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="NEXT.JS入门实践客户端和服务端代码 同构 ： 一套代码既可以跑在客户端也可以跑在服务端渲染一致优点：•    Next.js英文文档 Next.js中文文档 是一个轻量级的 React 服务端渲染应用框架•    默认支持服务端渲染•    自动根据页面进行代码分割•    基于页面的客户端路由方案•    基于 Webpack 的开发环境，支持热模块替换•    可以跟Koa或者其它Nod">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2021/01/17/nextjs/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="NEXT.JS入门实践客户端和服务端代码 同构 ： 一套代码既可以跑在客户端也可以跑在服务端渲染一致优点：•    Next.js英文文档 Next.js中文文档 是一个轻量级的 React 服务端渲染应用框架•    默认支持服务端渲染•    自动根据页面进行代码分割•    基于页面的客户端路由方案•    基于 Webpack 的开发环境，支持热模块替换•    可以跟Koa或者其它Nod">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-01-17T12:38:17.164Z">
<meta property="article:modified_time" content="2021-01-17T13:32:43.723Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-nextjs" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/17/nextjs/" class="article-date">
  <time class="dt-published" datetime="2021-01-17T12:38:17.164Z" itemprop="datePublished">2021-01-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="NEXT-JS入门实践"><a href="#NEXT-JS入门实践" class="headerlink" title="NEXT.JS入门实践"></a>NEXT.JS入门实践</h1><p>客户端和服务端代码 同构 ： 一套代码既可以跑在客户端也可以跑在服务端渲染一致<br>优点：<br>•    Next.js英文文档 Next.js中文文档 是一个轻量级的 React 服务端渲染应用框架<br>•    默认支持服务端渲染<br>•    自动根据页面进行代码分割<br>•    基于页面的客户端路由方案<br>•    基于 Webpack 的开发环境，支持热模块替换<br>•    可以跟Koa或者其它Node.js服务器进行集成<br>•    支持 Babel 和 Webpack 的配置项定制<br>•    静态文件服务 public</p>
<h2 id="创建一个-Next-js-应用"><a href="#创建一个-Next-js-应用" class="headerlink" title="创建一个 Next.js 应用"></a>创建一个 Next.js 应用</h2><p>通过执行 create-next-app创建应用，cd 进入您要在其中创建应用程序的目录，输入命令<br>npx create-next-app nextjs-blog –use-npm –example “<a target="_blank" rel="noopener" href="https://github.com/vercel/next-learn-starter/tree/master/learn-starter&quot;">https://github.com/vercel/next-learn-starter/tree/master/learn-starter&quot;</a><br>运行开发服务器<br>cd进入名为 nextjs-blog 的新目录<br>cd nextjs-blog<br>运行命令，这将在 3000 端口上启动 Next.js 应用程序的“开发服务器”。在浏览器中打开 <a target="_blank" rel="noopener" href="http://localhost:3000/">http://localhost:3000</a> 就会看到页面了。<br>npm run dev<br>编辑页面<br>确保 Next.js 开发服务器仍在运行<br>用你的文本编辑器打开 pages/index.js 文件，编辑内容后保存，浏览器会自动重新加载并更新页面<br>创建页面<br>Page 就是 React 组件， 放在 pages 目录下</p>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>1、文件系统路由，每个 page使用其文件名在pages的目录，作为路由（route）。<br>index路由，路由器会自动将命名为index的文件路由到目录的根目录。<br>• pages/index.js → /<br>• pages/blog/index.js → /blog<br>嵌套路由，<br>• pages/blog/first-post.js → /blog/first-post<br>• pages/dashboard/settings/username.js → /dashboard/settings/username<br><a target="_blank" rel="noopener" href="http://localhost:3000/blog/first-post%E5%8D%B3%E5%8F%AF%E6%9F%A5%E7%9C%8B%E9%A1%B5%E9%9D%A2">http://localhost:3000/blog/first-post即可查看页面</a><br>动态路由的 pages（页面）。例如pages/posts/[id].js 的文件，那么就可以通过 posts/1、posts/2 等类似的路径进行访问。<br>要匹配动态段，可以使用括号语法。这允许您匹配命名参数<br>• pages/blog/[slug].js → /blog/:slug (/blog/hello-world)<br>• pages/[username]/settings.js → /:username/settings (/foo/settings)<br>• pages/post/[…all].js → /post/* (/post/2020/id/title)</p>
<h2 id="用Link实现页面间导航"><a href="#用Link实现页面间导航" class="headerlink" title="用Link实现页面间导航"></a>用Link实现页面间导航</h2><p>2、使用Next.js的组件Link 跳转页面，实现组件切换局部刷新。 代替了<a href=''>触发浏览器refresh整个页面。<br>import Link from ‘next/link’;<br>//使用<Link>里面放需要一个<a>包裹连接</a></Link><br>export default function FirstPost() {<br>  return (<br>    &lt;&gt;<br>      <h1>First Post</h1><br>      <h2><br>        <Link href="/"><br>          <a>Back to home</a><br>        </Link><br>      </h2><br>    &lt;/&gt;<br>  )<br>}<br>如果需要给路由传参数，则使用query的形式<br>Client-side Navigation</p>
<h2 id="代码分割和预取"><a href="#代码分割和预取" class="headerlink" title="代码分割和预取"></a>代码分割和预取</h2><p>3、自动代码分割。相互独立，每个页面只加载该页面所需要的内容。<br>4、Prefetching： 如果使用了Link ，出现在浏览器中，Linked page 在后台就会预先获取。点击链接转换几乎是及时的。<br>资源、元数据和css</p>
<h2 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h2><p>根目录创建public文件夹，里面的静态资源可以像pages一样通过目录路径访问。<br>修改页面的metadata<br>组件中引入Head组件, 在组件中添加<br>import Head from ‘next/head’;<br>export default function FirstPost() {<br>  return (<br>    &lt;&gt;<br>      <Head><br>        <title>First Post</title><br>      </Head><br>      …<br>    &lt;/&gt;<br>  )<br>}</p>
<h2 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h2><p>支持“CSS-in-JS”库 styled-jsx，写在render中，格式为<style jsx><code>...</code></style>，注意中间是模板字符串。<br>组件内使用CSS Modules<br>首先根目录下创建components文件夹，里面创建layout.js文件，作为外层组件。<br>export default function Layout({ children }) {<br>  return <div>{children}</div><br>}<br>在pages/posts/first-post.js, import Layout<br>import Head from ‘next/head’<br>import Link from ‘next/link’<br>import Layout from ‘../../components/layout’<br>export default function FirstPost() {<br>  return (<br>    <Layout><br>      <Head><br>        <title>First Post</title><br>      </Head><br>      <h1>First Post</h1><br>      <h2><br>        <Link href="/"><br>          <a>Back to home</a><br>        </Link><br>      </h2><br>    </Layout><br>  )<br>}<br>支持添加css modules,文件必须以.modules.css结尾.<br>在components文件夹下创建layout.module.css内容为<br>.container {<br>  max-width: 36rem;<br>  padding: 0 1rem;<br>  margin: 3rem auto 6rem;<br>}<br>在layout.js中引入<br>import styles from ‘./layout.module.css’<br>export default function Layout({ children }) {<br>  return <div className={styles.container}>{children}</div><br>}<br>全局styles<br>在pages中添加App.js，这个App组件是顶级组件，在所有不同的页面中都是通用的。例如，当在页面之间导航时，你可以使用这个App组件来保持状态。<br>export default function App({ Component, pageProps }) {<br>  return &lt;Component {…pageProps} /&gt;<br>}<br>重启服务 npm run dev<br>创建顶级目录styles文件夹，新建global.css，然后在pages/_app.js引入，样式将在子组件中都生效。<br>Next.js使用postCSS解析css，可以添加配置文件postcss.config.js，自定义配置。</p>
<h2 id="预渲染和数据获取"><a href="#预渲染和数据获取" class="headerlink" title="预渲染和数据获取"></a>预渲染和数据获取</h2><p>• 预呈现：默认情况下，Next.js预渲染每个页面。这意味着Next.js提前为每个页面生成HTML，而不是全部由客户端JavaScript完成。预呈现可以带来更好的性能和SEO。<br>• 水合：预呈现的HTML都与该页面所需的最小JavaScript代码相关联。当页面被浏览器加载时，它的其他JavaScript代码会运行，使页面可完成全部交互。<br>• 查看是否预呈现：禁用浏览器JavaScript，看到你的应用程序是在没有JavaScript的情况下呈现的。这是因为Next.js已经将应用程序预渲染成静态HTML，允许您在不运行JavaScript的情况下查看应用程序UI。而没有Next.js的react应用,是看不到应用的。<br>预呈现的两种形式:静态生成和服务器端呈现。<br>不同之处在于它为页面生成HTML的时间。<br>• 静态生成：是在构建build时生成HTML的预呈现方法。然后在每次请求重用预呈现的HTML。<br>• 服务器端呈现：是在每次页面请求时，重新生成页面的 HTML预呈现方法 。<br>注意：在开发模式下(当你运行npm run dev或yarn dev时)，每个页面都会在每个请求上预渲染——即使是那些使用静态生成的页面。<br>何时使用静态生成or服务端渲染：你应该问自己:“我可以在用户请求之前预先渲染这个页面吗?”如果答案是肯定的，那么您应该选择静态生成。如果您不能在用户请求之前预呈现页面，也许您的页面显示了频繁更新的数据，并且页面内容在每次请求时都发生变化。在这种情况下，可以使用服务器端呈现。它会慢一些，但预渲染的页面将始终是最新的。或者您可以跳过预呈现，使用客户端JavaScript来填充频繁更新的数据。<br>有数据和没有数据的静态生成。<br>到目前为止都是没有数据的静态生成，<br>有数据的页面需要等获取数据后，再生成页面。</p>
<h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><p>getStaticProps以及如何使用它将外部博客数据导入索引页面。在导出组件的page里，导出一个asyn function 叫做getStaticProps<br>• getStaticProps在生产环境的build时运行，并且……<br>• 在函数内部，可以获取外部数据并将其作为props发送到页面。<br>export default function Home(props) { … }<br>export async function getStaticProps(context) {<br>    // 获取数据<br>  const data = await fetch(…);<br>  // The value of the <code>props</code> key will be passed to the <code>Home</code> component<br>  return {<br>    props: …<br>  }<br>}<br>getInitialProps是组件的静态方法，无论服务端渲染还是客户端渲染都会调用。<br>获取数据后，组件的props就能获取到getInitialProps return 的对象，render 的时候就能直接使用了。当服务端渲染时，getInitialProps将会把return数据序列化，就像JSON.stringify<br>getStaticProps会帮你告诉Next.js这个页面依赖一些数据，所以“当你在构建时预渲染这个页面时，一定要先解决它们!”<br>注意：在开发模式中，getStaticProps会在每个请求上运行。<br>现在，我们将使用文件系统向应用程序添加博客数据。每一篇博客文章都是一个markdown文件。<br>创建一个新的顶级目录posts(这与pages/posts不同)，在内部，创建两个文件:pre-rendering.md和ssg-ssr.md作为数据，然后用getStaticProps获取数据更新pages/index.js。<br>getStaticProps 细节<br>getStaticProps里除了可以使用文件系统获取数据，还可以使用API或者直接查询数据库。因为getStaticProps只在服务器端运行。它永远不会在客户端运行。它甚至不会包含在浏览器的JS包中。这意味着您可以编写诸如直接数据库查询之类的代码，而无需将它们发送到浏览器。<br>Development vs. Production<br>• 在开发中(npm run dev或yarn dev)， getStaticProps会在每个请求request上运行。<br>• 在生产中，getStaticProps在构建build时运行。<br>因为它是在构建时运行的，所以您不能使用仅在请求期间可用的数据，如查询参数或HTTP头。<br>从页面导出<br>getStaticProps只能从page导出。您不能从非页面文件中导出它。产生这种限制的原因之一是，React需要在呈现页面之前获得所有必需的数据。</p>
<h3 id="有数据的服务端预渲染"><a href="#有数据的服务端预渲染" class="headerlink" title="有数据的服务端预渲染"></a>有数据的服务端预渲染</h3><p>需要请求时获取数据怎么办<br>如果不能在用户请求之前预呈现页面，那么静态生成就不是一个好主意。也许您的页面显示了频繁更新的数据，并且页面内容在每次请求时都发生变化。在这种情况下，您可以尝试服务器端呈现或跳过预呈现。<br>如果你需要在请求时而不是在构建时获取数据，你可以尝试服务器端渲染:<br>在page中 用export getServerSideProps代替getStaticProps<br>export async function getServerSideProps(context) {<br>  return {<br>    props: {<br>      // props for your component<br>    }<br>  }<br>}<br>因为getServerSideProps是在请求时调用的，所以它的参数(context)包含特定于请求的参数。<br>只有当您需要预呈现一个必须在请求时获取数据的页面时，您才应该使用getServerSideProps。到第一个字节的时间Time to first byte(TTFB)将比getStaticProps慢，因为服务器必须对每个请求计算结果。而且如果没有额外的配置，CDN无法缓存结果。</p>
<h3 id="客户端渲染"><a href="#客户端渲染" class="headerlink" title="客户端渲染"></a>客户端渲染</h3><p>如果你不需要预渲染数据，你也可以使用以下策略(称为客户端渲染):<br>静态生成(预渲染)不需要外部数据的页面部分。<br>加载页面时，使用JavaScript从客户机获取外部数据，并填充其余部分。<br>例如，这种方法适用于用户指示板页面。因为指示板是一个私有的、特定于用户的页面，所以SEO是无关的，并且页面不需要预先渲染。数据经常更新，这就需要在请求时获取数据。</p>
<h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>我们已经用博客数据填充了索引页面，但是还没有创建单独的博客页面(下面是预期的结果)。我们希望这些页面的URL依赖于博客数据，这意味着我们需要使用动态路由。<br>getStaticPaths静态生成带有动态路由的页面<br>我们希望每一个post的路径为/posts/<id>，其中<id>是markdown文件的名称。我们有两个文件 ssg-ssr.md 和 pre-rendering.md, 我们希望他们的路径是 /posts/ssg-ssr and /posts/pre-rendering.<br>• 我们将在pages/posts下创建一个名为[id].js的页面，编写代码来渲染post页面，像创建其他页面一样，<br>• 并从这个page中 export function getStaticPath<br>• 最后，我们需要再次实现getStaticProps—这一次，用给定的id为博客文章获取必要的数据。getStaticProps将给出包含id的参数(因为文件名是[id].js)。<br>import Layout from ‘../../components/layout’<br>export default function Post() {<br>  return <Layout>…</Layout><br>}<br>export async function getStaticPaths() {<br>  // Return a list of possible value for id<br>  return [‘id’, ‘id’]<br>}<br>export async function getStaticProps({ params }) {<br>  // 根据params.id，获取blog post数据<br>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/17/nextjs/" data-id="ckk15fqss0000sify5do92xla" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/01/17/websocket/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2021/01/12/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/24/Websocket-2/">Websocket 2</a>
          </li>
        
          <li>
            <a href="/2021/01/17/websocket/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/01/17/nextjs/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/01/12/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2021/01/12/setup-my-blog/">setup_my_blog</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>